<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vector Grid (Motion → Add → Decay → 0)</title>
    <style>
      :root {
        --bg: #07090f;
        --panel: rgba(255, 255, 255, 0.06);
        --panelBorder: rgba(255, 255, 255, 0.14);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: radial-gradient(1200px 700px at 50% 20%, #10162a 0%, var(--bg) 70%);
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }
      .app {
        width: min(980px, 100%);
        padding: 14px;
        display: grid;
        gap: 12px;
      }
      .header {
        display: grid;
        gap: 6px;
        text-align: center;
        padding: 8px 10px;
      }
      .header h1 {
        margin: 0;
        font-size: 1.05rem;
        font-weight: 650;
        letter-spacing: 0.2px;
      }
      .header p {
        margin: 0;
        font-size: 0.8rem;
        color: var(--muted);
      }
      .status {
        font-size: 0.75rem;
        color: var(--muted);
      }

      .stage {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        align-items: start;
      }

      .canvasWrap {
        border-radius: 18px;
        border: 1px solid var(--panelBorder);
        background: rgba(0, 0, 0, 0.35);
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
        overflow: hidden;
      }
      .canvasInner {
        position: relative;
        width: 100%;
        aspect-ratio: 1 / 1;
      }
      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }

      .controls {
        border-radius: 14px;
        border: 1px solid var(--panelBorder);
        background: var(--panel);
        padding: 10px 10px 6px;
        display: grid;
        gap: 10px;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }
      .row label {
        font-size: 0.78rem;
        color: rgba(255,255,255,0.85);
        user-select: none;
      }
      .row .val {
        font-variant-numeric: tabular-nums;
        font-size: 0.78rem;
        color: rgba(255,255,255,0.85);
        min-width: 72px;
        text-align: right;
      }
      input[type="range"] { width: 100%; }
      .grid2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .toggles {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .toggle {
        display: flex;
        gap: 8px;
        align-items: center;
        padding: 8px 10px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.04);
        user-select: none;
      }
      .toggle input { transform: translateY(1px); }
      .hint {
        font-size: 0.76rem;
        color: var(--muted);
        line-height: 1.35;
        padding: 2px 2px 6px;
      }
      .btnRow {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      button {
        appearance: none;
        border: 1px solid rgba(255,255,255,0.18);
        padding: 9px 12px;
        border-radius: 12px;
        background: rgba(255,255,255,0.06);
        color: var(--text);
        cursor: pointer;
      }
      button:hover { background: rgba(255,255,255,0.09); }
      button:active { transform: translateY(1px); }

      video { display: none; }

      @media (min-width: 980px) {
        .stage {
          grid-template-columns: 1fr 340px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="header">
        <h1>Vector Grid: Motion → Add Vectors → Decay → 0</h1>
        <p>
          Each cell estimates local motion (direction + intensity), adds it to its stored vector, then
          decays magnitude toward 0 and stops there.
        </p>
        <div class="status" id="status">Camera: idle (you can still drag on the grid to inject vectors)</div>
      </div>

      <video id="cam" autoplay playsinline muted></video>

      <div class="stage">
        <div class="canvasWrap">
          <div class="canvasInner">
            <canvas id="view"></canvas>
          </div>
        </div>

        <div class="controls">
          <div class="toggles">
            <label class="toggle"><input id="useCam" type="checkbox" checked /> Use camera motion</label>
            <label class="toggle"><input id="showCam" type="checkbox" /> Show camera background</label>
          </div>

          <div class="grid2">
            <div>
              <div class="row">
                <label for="cols">Grid Columns</label>
                <div class="val" id="colsVal"></div>
              </div>
              <input id="cols" type="range" min="8" max="64" step="1" />
            </div>
            <div>
              <div class="row">
                <label for="rows">Grid Rows</label>
                <div class="val" id="rowsVal"></div>
              </div>
              <input id="rows" type="range" min="8" max="64" step="1" />
            </div>
          </div>

          <div>
            <div class="row">
              <label for="gain">Motion → Vector Gain</label>
              <div class="val" id="gainVal"></div>
            </div>
            <input id="gain" type="range" min="0" max="6" step="0.01" />
          </div>

          <div>
            <div class="row">
              <label for="decay">Decay (per second)</label>
              <div class="val" id="decayVal"></div>
            </div>
            <input id="decay" type="range" min="0" max="8" step="0.01" />
          </div>

          <div class="grid2">
            <div>
              <div class="row">
                <label for="maxLen">Max Arrow Length (px)</label>
                <div class="val" id="maxLenVal"></div>
              </div>
              <input id="maxLen" type="range" min="6" max="80" step="1" />
            </div>
            <div>
              <div class="row">
                <label for="zeroEps">Zero Snap Threshold</label>
                <div class="val" id="zeroEpsVal"></div>
              </div>
              <input id="zeroEps" type="range" min="0" max="0.5" step="0.005" />
            </div>
          </div>

          <div class="grid2">
            <div>
              <div class="row">
                <label for="smooth">Flow Smoothing</label>
                <div class="val" id="smoothVal"></div>
              </div>
              <input id="smooth" type="range" min="0" max="0.95" step="0.01" />
            </div>
            <div>
              <div class="row">
                <label for="dragGain">Mouse Drag Gain</label>
                <div class="val" id="dragGainVal"></div>
              </div>
              <input id="dragGain" type="range" min="0" max="6" step="0.01" />
            </div>
          </div>

          <div class="btnRow">
            <button id="zeroAll">Zero All Vectors</button>
            <button id="randomPulse">Random Pulse</button>
          </div>

          <div class="hint">
            <b>Inspecting behavior:</b><br />
            • Drag on the grid to inject a vector into nearby cells (adds to existing).<br />
            • Stop moving and watch arrows decay smoothly to 0 and then sit there.<br />
            • If the camera is on, wave your hand and you should see local direction fields appear.
          </div>
        </div>
      </div>
    </div>

    <script>
      // ---- Small helper math ----
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const hypot = (x, y) => Math.hypot(x, y);

      // Exponential decay multiplier for a per-second decay rate:
      // v *= exp(-rate * dt). Bigger rate => faster fade.
      const decayMul = (ratePerSec, dt) => Math.exp(-ratePerSec * dt);

      // ---- DOM ----
      const canvas = document.getElementById("view");
      const ctx = canvas.getContext("2d", { alpha: false });

      const video = document.getElementById("cam");
      const statusEl = document.getElementById("status");

      const useCamEl = document.getElementById("useCam");
      const showCamEl = document.getElementById("showCam");

      const colsEl = document.getElementById("cols");
      const rowsEl = document.getElementById("rows");
      const gainEl = document.getElementById("gain");
      const decayEl = document.getElementById("decay");
      const maxLenEl = document.getElementById("maxLen");
      const zeroEpsEl = document.getElementById("zeroEps");
      const smoothEl = document.getElementById("smooth");
      const dragGainEl = document.getElementById("dragGain");

      const colsVal = document.getElementById("colsVal");
      const rowsVal = document.getElementById("rowsVal");
      const gainVal = document.getElementById("gainVal");
      const decayVal = document.getElementById("decayVal");
      const maxLenVal = document.getElementById("maxLenVal");
      const zeroEpsVal = document.getElementById("zeroEpsVal");
      const smoothVal = document.getElementById("smoothVal");
      const dragGainVal = document.getElementById("dragGainVal");

      const zeroAllBtn = document.getElementById("zeroAll");
      const randomPulseBtn = document.getElementById("randomPulse");

      // ---- Settings ----
      const settings = {
        cols: 28,
        rows: 28,
        gain: 1.2,
        decay: 2.2,
        maxLen: 34,
        zeroEps: 0.03,
        smooth: 0.55,
        dragGain: 2.0,
      };

      // ---- Vector field storage (per cell) ----
      let fieldVX = new Float32Array(settings.cols * settings.rows);
      let fieldVY = new Float32Array(settings.cols * settings.rows);

      // Smoothed measured flow (from camera) so you can separately tune smoothing.
      let measVX = new Float32Array(settings.cols * settings.rows);
      let measVY = new Float32Array(settings.cols * settings.rows);

      function rebuildField() {
        const n = settings.cols * settings.rows;
        fieldVX = new Float32Array(n);
        fieldVY = new Float32Array(n);
        measVX = new Float32Array(n);
        measVY = new Float32Array(n);
      }

      // ---- Responsive canvas ----
      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // ---- Motion analysis setup (downscaled) ----
      // Keep small for speed. Optical flow per cell uses local gradients.
      const ANALYSIS_W = 160;
      const ANALYSIS_H = 160; // square analysis so mapping to view is easy
      const analysisCanvas = document.createElement("canvas");
      analysisCanvas.width = ANALYSIS_W;
      analysisCanvas.height = ANALYSIS_H;
      const aCtx = analysisCanvas.getContext("2d", { willReadFrequently: true });

      let prevGray = null; // Float32Array
      let hasCamera = false;

      async function startCamera() {
        try {
          statusEl.textContent = "Camera: requesting access…";
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user" },
            audio: false,
          });
          video.srcObject = stream;
          await video.play();
          hasCamera = true;
          statusEl.textContent = "Camera: on (wave your hand, or drag on the grid)";
        } catch (e) {
          hasCamera = false;
          statusEl.textContent = `Camera: unavailable (${e?.message || "permission denied"}) — drag to test vectors`;
        }
      }
      startCamera();

      // ---- Convert ImageData -> grayscale float array ----
      function toGray(imageData) {
        const { data, width, height } = imageData;
        const out = new Float32Array(width * height);
        for (let i = 0, p = 0; i < out.length; i++, p += 4) {
          // luminance-ish (fast)
          out[i] = 0.299 * data[p] + 0.587 * data[p + 1] + 0.114 * data[p + 2];
        }
        return out;
      }

      // ---- Coarse Lucas–Kanade per-cell flow estimate ----
      // For each cell, sum over pixels of Ix, Iy, It terms and solve:
      // [sum Ix^2  sum IxIy][u] = -[sum IxIt]
      // [sum IxIy  sum Iy^2][v]   [sum IyIt]
      function estimateFlowGrid(currGray, prevGray, w, h, cols, rows, outU, outV) {
        const cellW = w / cols;
        const cellH = h / rows;

        const EPS_DET = 1e-3;
        const MAX_FLOW = 6.0; // clamp in analysis pixels/frame to avoid spikes

        for (let gy = 0; gy < rows; gy++) {
          const y0 = Math.floor(gy * cellH);
          const y1 = Math.floor((gy + 1) * cellH);

          for (let gx = 0; gx < cols; gx++) {
            const x0 = Math.floor(gx * cellW);
            const x1 = Math.floor((gx + 1) * cellW);

            let sumIx2 = 0, sumIy2 = 0, sumIxIy = 0, sumIxIt = 0, sumIyIt = 0;

            // Avoid borders for gradient computation
            const ys = Math.max(1, y0);
            const ye = Math.min(h - 2, y1);
            const xs = Math.max(1, x0);
            const xe = Math.min(w - 2, x1);

            for (let y = ys; y <= ye; y++) {
              const row = y * w;
              const rowU = (y - 1) * w;
              const rowD = (y + 1) * w;

              for (let x = xs; x <= xe; x++) {
                const i = row + x;

                // Simple central difference gradients
                const ix = 0.5 * (currGray[i + 1] - currGray[i - 1]);
                const iy = 0.5 * (currGray[rowD + x] - currGray[rowU + x]);
                const it = currGray[i] - prevGray[i];

                sumIx2 += ix * ix;
                sumIy2 += iy * iy;
                sumIxIy += ix * iy;
                sumIxIt += ix * it;
                sumIyIt += iy * it;
              }
            }

            const det = sumIx2 * sumIy2 - sumIxIy * sumIxIy;
            let u = 0, v = 0;
            if (det > EPS_DET) {
              // u = -(sumIy2*b0 - sumIxIy*b1)/det
              // v =  (sumIxIy*b0 - sumIx2*b1)/det
              const b0 = sumIxIt;
              const b1 = sumIyIt;
              u = -(sumIy2 * b0 - sumIxIy * b1) / det;
              v = (sumIxIy * b0 - sumIx2 * b1) / det;

              // Clamp outliers
              u = clamp(u, -MAX_FLOW, MAX_FLOW);
              v = clamp(v, -MAX_FLOW, MAX_FLOW);
            }

            const idx = gy * cols + gx;
            outU[idx] = u;
            outV[idx] = v;
          }
        }
      }

      // ---- Add measured motion vectors into stored field vectors ----
      function addMotionIntoField(dt) {
        if (!useCamEl.checked || !hasCamera || video.readyState < 2) return;

        // Draw video into analysis canvas (cover)
        const vw = video.videoWidth || 640;
        const vh = video.videoHeight || 480;
        if (!vw || !vh) return;

        // Center-crop to square then scale to ANALYSIS_W/H
        const side = Math.min(vw, vh);
        const sx = Math.floor((vw - side) / 2);
        const sy = Math.floor((vh - side) / 2);

        aCtx.drawImage(video, sx, sy, side, side, 0, 0, ANALYSIS_W, ANALYSIS_H);
        const img = aCtx.getImageData(0, 0, ANALYSIS_W, ANALYSIS_H);
        const currGray = toGray(img);

        if (!prevGray) {
          prevGray = currGray;
          return;
        }

        // Estimate per-cell flow in analysis pixels/frame
        estimateFlowGrid(currGray, prevGray, ANALYSIS_W, ANALYSIS_H, settings.cols, settings.rows, measVX, measVY);
        prevGray = currGray;

        // Smooth measured flow (low-pass)
        const s = settings.smooth;          // keep previous
        const inv = 1 - s;                 // take new
        // Add into field (vector addition) with gain
        const g = settings.gain;

        for (let i = 0; i < fieldVX.length; i++) {
          // Smooth measurement
          measVX[i] = measVX[i] * inv + measVX[i] * 0; // noop safety; measured already in measVX
          measVY[i] = measVY[i] * inv + measVY[i] * 0;

          // Actually smooth by blending previous stored "measured" with newly estimated:
          // We need a temp; easiest: compute new estimates into temp arrays, but we reuse measVX/measVY.
          // So we do a mild smoothing by blending the vector field itself below instead.

          // Add measured flow into stored field:
          fieldVX[i] += measVX[i] * g;
          fieldVY[i] += measVY[i] * g;
        }

        // Optional: stabilize by slightly scaling the add by dt (so it’s less FPS-dependent)
        // If you prefer: fieldVX[i] += measVX[i] * g * (60 * dt);
        // For now keep straightforward.
      }

      // ---- Decay field vectors toward 0 and snap at epsilon ----
      function decayField(dt) {
        const mul = decayMul(settings.decay, dt);
        const eps = settings.zeroEps;

        for (let i = 0; i < fieldVX.length; i++) {
          let vx = fieldVX[i] * mul;
          let vy = fieldVY[i] * mul;

          // Snap-to-zero so it truly reaches 0
          if (Math.abs(vx) < eps) vx = 0;
          if (Math.abs(vy) < eps) vy = 0;

          fieldVX[i] = vx;
          fieldVY[i] = vy;
        }
      }

      // ---- Rendering ----
      function drawArrow(x, y, dx, dy, maxLen) {
        const mag = hypot(dx, dy);
        if (mag <= 1e-6) return;

        const len = Math.min(maxLen, mag);
        const ux = dx / mag;
        const uy = dy / mag;

        const x2 = x + ux * len;
        const y2 = y + uy * len;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x2, y2);

        // Arrowhead
        const head = Math.max(5, Math.min(10, len * 0.35));
        const angle = Math.atan2(uy, ux);
        const a1 = angle + Math.PI * 0.85;
        const a2 = angle - Math.PI * 0.85;

        ctx.lineTo(x2 + Math.cos(a1) * head, y2 + Math.sin(a1) * head);
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 + Math.cos(a2) * head, y2 + Math.sin(a2) * head);
        ctx.stroke();
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;

        // Background
        ctx.fillStyle = "#050711";
        ctx.fillRect(0, 0, w, h);

        // Optional camera underlay (very subtle)
        if (showCamEl.checked && hasCamera && video.readyState >= 2) {
          // Draw with slight alpha so arrows stay readable
          ctx.save();
          ctx.globalAlpha = 0.18;

          // Draw cover-cropped video to square canvas
          const vw = video.videoWidth || 640;
          const vh = video.videoHeight || 480;
          const side = Math.min(vw, vh);
          const sx = Math.floor((vw - side) / 2);
          const sy = Math.floor((vh - side) / 2);
          ctx.drawImage(video, sx, sy, side, side, 0, 0, w, h);
          ctx.restore();

          // Darken back down a bit
          ctx.fillStyle = "rgba(0,0,0,0.35)";
          ctx.fillRect(0, 0, w, h);
        }

        const cols = settings.cols;
        const rows = settings.rows;
        const cellW = w / cols;
        const cellH = h / rows;

        // Grid lines
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.lineWidth = Math.max(1, (window.devicePixelRatio || 1));
        ctx.beginPath();
        for (let x = 0; x <= cols; x++) {
          const px = x * cellW;
          ctx.moveTo(px, 0);
          ctx.lineTo(px, h);
        }
        for (let y = 0; y <= rows; y++) {
          const py = y * cellH;
          ctx.moveTo(0, py);
          ctx.lineTo(w, py);
        }
        ctx.stroke();
        ctx.restore();

        // Arrows
        const maxLen = settings.maxLen * (window.devicePixelRatio || 1);
        const scale = 7.5 * (window.devicePixelRatio || 1); // map "field units" to pixels (tweak as needed)

        for (let gy = 0; gy < rows; gy++) {
          const cy = (gy + 0.5) * cellH;
          for (let gx = 0; gx < cols; gx++) {
            const cx = (gx + 0.5) * cellW;
            const i = gy * cols + gx;

            const vx = fieldVX[i];
            const vy = fieldVY[i];
            const mag = hypot(vx, vy);

            if (mag <= 1e-6) continue;

            // Brightness based on magnitude
            const alpha = clamp(0.12 + mag * 0.18, 0.12, 0.95);

            ctx.save();
            ctx.strokeStyle = `rgba(120, 210, 255, ${alpha})`;
            ctx.lineWidth = Math.max(1.2, 1.6 * (window.devicePixelRatio || 1));
            ctx.lineCap = "round";

            drawArrow(cx, cy, vx * scale, vy * scale, maxLen);
            ctx.restore();
          }
        }

        // Outer border vignette
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.09)";
        ctx.lineWidth = Math.max(2, 2 * (window.devicePixelRatio || 1));
        ctx.strokeRect(0, 0, w, h);
        ctx.restore();
      }

      // ---- Mouse drag injection (adds vectors) ----
      let dragging = false;
      let lastPt = null;

      function canvasToGrid(px, py) {
        const rect = canvas.getBoundingClientRect();
        const nx = (px - rect.left) / rect.width;  // 0..1
        const ny = (py - rect.top) / rect.height;  // 0..1
        const gx = clamp(Math.floor(nx * settings.cols), 0, settings.cols - 1);
        const gy = clamp(Math.floor(ny * settings.rows), 0, settings.rows - 1);
        return { gx, gy, nx, ny };
      }

      function addVectorAt(gx, gy, vx, vy) {
        const cols = settings.cols;
        const rows = settings.rows;

        // Apply to a small neighborhood with falloff (so it feels “field-like”)
        for (let oy = -1; oy <= 1; oy++) {
          for (let ox = -1; ox <= 1; ox++) {
            const x = gx + ox;
            const y = gy + oy;
            if (x < 0 || y < 0 || x >= cols || y >= rows) continue;

            const dist2 = ox * ox + oy * oy;
            const w = dist2 === 0 ? 1.0 : (dist2 === 1 ? 0.55 : 0.25);

            const i = y * cols + x;
            fieldVX[i] += vx * w;
            fieldVY[i] += vy * w;
          }
        }
      }

      canvas.addEventListener("pointerdown", (e) => {
        dragging = true;
        canvas.setPointerCapture(e.pointerId);
        lastPt = { x: e.clientX, y: e.clientY };
      });

      canvas.addEventListener("pointermove", (e) => {
        if (!dragging || !lastPt) return;

        const dx = e.clientX - lastPt.x;
        const dy = e.clientY - lastPt.y;
        lastPt = { x: e.clientX, y: e.clientY };

        const { gx, gy } = canvasToGrid(e.clientX, e.clientY);

        // Convert screen drag pixels → field units
        const g = settings.dragGain * 0.08;
        addVectorAt(gx, gy, dx * g, dy * g);
      });

      canvas.addEventListener("pointerup", (e) => {
        dragging = false;
        lastPt = null;
        try { canvas.releasePointerCapture(e.pointerId); } catch {}
      });

      // ---- UI wiring ----
      function bindRange(el, valEl, key, fmt) {
        el.value = String(settings[key]);
        valEl.textContent = fmt(settings[key]);
        el.addEventListener("input", () => {
          settings[key] = parseFloat(el.value);
          valEl.textContent = fmt(settings[key]);

          if (key === "cols" || key === "rows") rebuildField();
        });
      }

      bindRange(colsEl, colsVal, "cols", v => `${v | 0}`);
      bindRange(rowsEl, rowsVal, "rows", v => `${v | 0}`);
      bindRange(gainEl, gainVal, "gain", v => v.toFixed(2));
      bindRange(decayEl, decayVal, "decay", v => v.toFixed(2));
      bindRange(maxLenEl, maxLenVal, "maxLen", v => `${v | 0}`);
      bindRange(zeroEpsEl, zeroEpsVal, "zeroEps", v => v.toFixed(3));
      bindRange(smoothEl, smoothVal, "smooth", v => v.toFixed(2));
      bindRange(dragGainEl, dragGainVal, "dragGain", v => v.toFixed(2));

      zeroAllBtn.addEventListener("click", () => {
        fieldVX.fill(0);
        fieldVY.fill(0);
      });

      randomPulseBtn.addEventListener("click", () => {
        for (let i = 0; i < fieldVX.length; i++) {
          const a = (Math.random() * Math.PI * 2);
          const m = Math.random() * 2.5;
          fieldVX[i] += Math.cos(a) * m;
          fieldVY[i] += Math.sin(a) * m;
        }
      });

      // ---- Main loop ----
      let lastTime = performance.now();

      function frame(now) {
        const dt = Math.min(0.05, (now - lastTime) / 1000); // clamp dt for stability
        lastTime = now;

        // Resize if layout changed
        // (cheap check: if CSS size changed, backing store will be wrong)
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const desiredW = Math.floor(rect.width * dpr);
        const desiredH = Math.floor(rect.height * dpr);
        if (canvas.width !== desiredW || canvas.height !== desiredH) resizeCanvas();

        // Camera motion → add vectors
        addMotionIntoField(dt);

        // Decay stored vectors toward 0
        decayField(dt);

        // Render
        render();

        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    </script>
  </body>
</html>
